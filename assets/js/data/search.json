[ { "title": "js实现PriorityQueue类", "url": "/posts/js%E5%AE%9E%E7%8E%B0PriorityQueue%E7%B1%BB/", "categories": "data-construct, queue, priority-heap", "tags": "", "date": "2022-09-16 15:08:00 +0800", "snippet": "js原生是没有提供这种复杂数据结构的（默默的羡慕一下java的世界）。为什么需要这种结构的呢？这种结构的优势又是什么呢？Queue vs PriorityQueue我们对这个词都不陌生，女王，哦，不，是：队列。队列的特点就是“先进先出”，进、出的时间效率都是O(1)；在js世界中，使用朴素的Array结构就可以模拟。那如果进、出都是有条件的，我们会怎么处理呢？比如，一堆学生在一个房间里，现在需要一个一个按需叫他们出来谈话，我们现在定一个规则就是O(1)时间内，按照学生的身高由高到低出来；而在谈话的过程中呢，又会有一些新的学生进入教室，那我们就需要通过某种结构进行管理，某种方法进行插入，以达到我们能O(1)效率找到当前学生中最高的目标。列举的这个场景，比较的维度还是线性的：身高（数值对比）。数据结构中的大顶堆可以解决这个问题。那如果现在排序的规则发生变化了呢？诸如，按照学生家庭住址的经纬度（二次元关系，非线形关系），我们又该如何处理呢？此时堆中的value不是单纯的值，而可能是任何结构的数据。我们可以抽取出所谓的排序规则为：comparetor。在构建堆的过程中都使用comparetor对节点进行位置的确定。Java中的PriorityQueue论原厂装备来，无疑java这种天生富贵的静态语言自带的武器简直爆表。官方文档中对此数据结构的解释：链接PriorityQueue类基于priority heap，并且其实现了Collection类和Iterator类的可选方法。从性能的角度来看：offer、poll、add（进出队列的函数）的时间效率是O(logn)；contain、remove(object)为线性时间O(n)；peek（获取元素）等操作为常量时间O(1)。js实现PriorityQueue需要实现的几个方法如下：实现基于的数据结构也是堆结构（用array模拟二叉树结构）。// 大顶堆const defaultComparetor = (a, b) =&amp;gt; b - aclass PriorityQueue { constructor(comparetor) { this.queue = [] this.comparetor = comparetor } _swap(x, y) { const tmp = this. queue[x] this.queue[x] = this.queue[y] this.queue[y] = tmp } _downCheck(loc) { const [lLoc, rLoc] = [2 * loc + 1, 2 * loc + 2] if (this.queue[lLoc] !== undefined) { if (this.comparetor(this.queue[loc], this.queue[lLoc]) &amp;gt; 0) { this._swap(loc, lLoc) this._downCheck(lLoc) } } if (this.queue[rLoc] !== undefined) { if (this.comparetor(this.queue[loc], this.queue[rLoc]) &amp;gt; 0) { this._swap(loc, rLoc) this._downCheck(rLoc) } } } _upCheck(cur) { while (cur &amp;gt; 0) { const parent = (cur - (cur % 2 === 0 ? 2 : 1)) / 2 if (this.comparetor(this.queue[parent], this.queue[cur]) &amp;gt; 0) { this._swap(parent, cur) cur = parent } else { break } } } getLen() { return this.queue.length } isEmpty() { return this.getLen() === 0 } // 删除指定元素 del (x) { const loc = this.queue.indexOf(x) this._swap(loc, this.getLen() - 1) this.queue.pop() this._upCheck(loc) this._downCheck(loc) } // 插入 add(x) { this.queue.push(x) let cur = this.getLen() - 1 this._upCheck(cur) } // 取堆顶元素 poll() { this._swap(0, this.getLen() - 1) const top = this.queue.pop() this._downCheck(0) return top } peek() { return this.queue[0] }}" }, { "title": "如何使用数据结构解决数据依赖的问题", "url": "/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E4%BE%9D%E8%B5%96%E7%9A%84%E9%97%AE%E9%A2%98/", "categories": "sideEffect, tree", "tags": "", "date": "2022-09-16 15:08:00 +0800", "snippet": "背景比如如下的场景，在一个数据洞察的场景下，筛选器之间的值存在相互的依赖关系（但不会构成环）；这个图中标注了筛选器之间的依赖关系。那我们如何能更好的抽象一种能力，去解决这种依赖关系呢？树结构通过这个图和实际场景的逻辑关系，我们能发现，箭头是不会构成环的，否则会导致依赖无限循环下去。根据上图的案例我们可以抽象出其有向图的结构：比如，我们切换了province，那在图中我们找到了代表这个值的节点，并递归向下获取其所有子孙节点的最新值（同步/异步请求获取数据集合）。基于业务场景并不存在root到某个叶子节点的路径有&amp;gt;=2的可能性，因此我们可以用树结构来抽象这层关系。因此，到这里我们需要做的几件事情： 构造节点； 构造树关系； 实现某个节点的值变化，递归收集其子孙的最新值；class TreeNode { constructor(key, rawKey, defaultVal) { this.key = key; // 唯一表示节点的id this.children = null; // 孩子节点 this.generator = () =&amp;gt; {} ... }}class RelTree { constructor(arr) { /** * @property {Map} keyNodeMap &amp;lt;key, node&amp;gt; O(1)时间内通过key获取node */ this.keyNodeMap = new Map(); /** * @property {Map} keyPathsMap &amp;lt;key, paths&amp;gt; O(1)时间内获取key对应的node，其从root到node的paths集合 */ this.keyPathsMap = new Map(); this.root = get(this.build(arr, null, []), &#39;0&#39;); } isLeafNode(node) {...} build (params) {...} async getFlattenRelInfo(params) { //.. const { node } = params let flatten = {} // iterable中会调用node.generator方法实现同步或异步操作 for await (let res of iterable(node.chidlren)) { flatten[res.id] = res.value const childNode = this.keyNaodeMap.get(res.id) if (childNode.children) { const childFlatten = await getFlattenRelInfo({ node: childNode, ...}) flatten = { ...flatten, ...childFlatten } } } return flatten } async collect(params) { const { targetKey, value: nextVal } = params const nextInfo = { [targetKey]: nextVal, }; // 如果是叶子节点不会触发任何side effect if (this.isLeafNode(targetKey)) return nextInfo; // find node by targetKey const node = this.keyNaodeMap.get(targetKey) // service logic ... const flattenInfo = await this.getFlattenRelInfo(...) // 递归获取后代节点的最新值 return Object.assign( {}, flattenInfo, nextInfo, ); }}待优化这个方法主要还是解决业务场景的一些问题，但是这个思路可以帮助解决数据关系有复杂依赖的场景。" }, { "title": "如何判断图片的实际类型?", "url": "/posts/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%9B%BE%E7%89%87%E7%9A%84%E5%AE%9E%E9%99%85%E7%B1%BB%E5%9E%8B/", "categories": "redux, redux-tooltik, immer", "tags": "", "date": "2022-07-15 16:01:19 +0800", "snippet": "背景场景需要能够真实的判断图片的类型，针对上传等任务对不符合的文件类型在前端侧进行拦截。比如用户将动态的webp图片类型手动改为png，只通过file.type检查文件的类型其实不是其actual type。因此需要提供一种更为有效的方式来判断图片的真实类型。解决方法任何文件的实质都是一堆二进制，而有一个称为“magic number”的序列被标注为识别文件唯一类型的签名。如果我们知道了不同文件类型的文件头签名，就可以通过分析文件数据对文件进行类别的判断了呢？在wiki上提供了一个不同文件类型的签名列表信息，因为需求暂时只涉及一些常见图片类型的处理，我们只需要考虑images/png、images/jpeg、images/gif、images/svg + xml 、images/webp等。（需要完成的图片类型，可参考 完整图片类型）(黄色标注的部分，即为可以唯一标识判断图片类型的签名前缀)但比如svg这种xml语法的格式，我们可以直接通过file.type进行确认了（同其他图片文件的解析语法不同）。整体的解析流程如下：核心主要是获取文件的十六进制签名，和我们已有的图片类型签名进行核对，如果有命中的，则表示匹配成功；对于签名中无法匹配的，我们可以通过dataURL获取其文件的mimeType，判断其是否为svg类型。另一个问题通过上面的方法，似乎是解决了背景中提出的问题，但这个过程中又出现了一个棘手的问题，需要排除webp中的动态格式。（webp竟然支持动画！一口老血吐了出来）。既然webp能支持动画的，说明其数据层面上对动画做了数据配置，参考官方文档,webp图片类型的二进制格式为RIFF格式：每个chunk包涵的内容：chunk-header(签名) + chunk size + chunk payload(数据)。对于可以支持动画的webp格式文件，其需要扩展chunk（VP8X）：其中A字段如果设置为1，那么表示支持动画；并需要在ANIM和ANMF两个chunk中配置相应的动画数据。因此我们可以通过偏移量来获取扩展chunk的信息，并判断A（1个bit）的标识是否设置。onst extendChunkName = &#39;VP8X&#39;const ccipChunkName = &#39;ICCP&#39;const animationBitLoc = 6const iccBitLoc = 3export const isExtendWebpType = (buffer) =&amp;gt; { const chunkHeader = getISOFromBufferSlice(buffer, getByteOccus(12, 4)).join(&#39;&#39;) return chunkHeader === extendChunkName}// 参考 https://developers.google.com/speed/webp/docs/riff_container#animationexport const supportAnimation = (buffer) =&amp;gt; { const option = getBinaryFromBufferSlice(buffer, getByteOccus(16, 1)).join(&#39;&#39;) const nextChunkHeader = getISOFromBufferSlice(buffer, getByteOccus(30, 4)).join(&#39;&#39;) // hack: 针对一些转码的webp，其字段option设置的不准确，需要做一下兼容判断 if (nextChunkHeader === ccipChunkName &amp;amp;&amp;amp; parseInt(option[iccBitLoc] || 0) === 0) return false return parseInt(option[animationBitLoc] || 0) === 1}根据以上的分析，我们可以大致分出动态的webp格式图片了：具体的实现可参考：useImgTypeService.js总结 通过文件的数字签名（其可唯一标识文件格式），确定文件的类型；（可以参考一个node库file-type 包含了对多种文件类型的判断）； 通过对webp扩展格式的检测，可以确定其是否支持动画。" }, { "title": "@redux-tooltik是如何使用immer的？", "url": "/posts/@redux-tooltik%E6%98%AF%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8immer%E7%9A%84/", "categories": "redux, redux-tooltik, immer", "tags": "", "date": "2022-07-08 15:20:54 +0800", "snippet": "一些碎碎念使用redux，是为了做复杂的数据管理；但对于很多使用redux的人来说，配置繁琐而重复的模版文件，简直是一场永无止尽的噩梦。 我们需要reducer； 我们需要action; 我们需要异步action； 我们需要确认，在reducer中修改嵌套过深的state是否有效，否则会导致react-redux中判断shouldComponentUpdate失效，从而无法进行组件re-render； … 写到这里我已经感到痛心疾首了，我们为了解决一个问题，又引入了另一问题；但是还好这个世界总是有“聪明的人”存在，开发出省时省力的工具，帮助开发人员们降低理解及使用成本（羡慕不已）。使用体验从我自己使用RTK来说，我个人感觉很好用的就是其文档中描述的： 降低了写reducer及action的成本，通过createSlice即可返回需要的reducers、actions； 降低了对异步action的处理成本，通过createAsyncThunk返回一个创建promise请求的createAction，这个promise可以被中途取消；createAction同样返回了pending\\fufilled\\rejected的同步action，便于用户直接在exteralReducers中针对三种情况进行state的更新： extraReducers: (builder) =&amp;gt; { builder.addCase(fetchPreviewImage.pending, (state) =&amp;gt; { state.url = &#39;&#39;; state.loading = true; }); builder.addCase(fetchPreviewImage.fulfilled, (state, action) =&amp;gt; { state.url = action.payload?.imageUrl; state.loading = false; }); builder.addCase(fetchPreviewImage.rejected, (state) =&amp;gt; { state.url = &#39;&#39;; state.loading = false; }); }, 在createSlice/createReducer中自动引入了immer，我们可以终于可以从“解构构造新对象返回state的方式”，直接跳到“直接修改state”的直观防止，即： // 解构重组方式 function updateVeryNestedField(state, action) { return { ...state, first: { ...state.first, second: { ...state.first.second, [action.someId]: { ...state.first.second[action.someId], fourth: action.someValue } } } } } // immer直接修改的方式 function updateNestedState(state, action) { let nestedState = state.nestedState // ERROR: this directly modifies the existing object reference - don&#39;t do this! nestedState.nestedField = action.data return { ...state, nestedState } }之所以要内置immer，作者在文档中也解释的很清楚了：immutable的数据结构在reducer修改中更为可读，并且其直接修改的方式降低了解构生成对象引入bug的问题。文档中推荐的RTK自带的query功能，帮助fetch及缓存的相关功能，我是用的项目上暂时还未涉猎。（因为没有很细致的看文档）在开发调试期间，出现了一个让我很困惑的问题，createSlice中reducer函数打印出的state竟然是Proxy对象，如下：调试到这里的时候，我整个人都惊呆了；当时还没看createSlice的源码（且没有细读文档…），并不知道其使用immer对象中proxy的神奇之处。当时黑人问号缀满了我的扁平的额头：redux中reducer需要返回的state应该是纯js对象呀，现在返回proxy是什么情况，那middleware在dispatch的过程中又是这么处理这个proxy的呢？带着这个愚蠢的疑问（是我想的复杂了…）去看了源码实现。createSlice做了什么？createSlice通过用户定义的reducers及name等，返回了一个slice对象，这个对象包含了actions、reducer等我们业务需要的对象： 多个reducer可以通过redux提供的combineReducers方法进行整合； actions用于我们出发dispatch的调用（不需要我们额外的通过createAction创建了）；在createSlice函数中返回的reducer如下：reducer(state, action) { if (!_reducer) _reducer = buildReducer() return _reducer(state, action) },其调用了buildReducer：function buildReducer() { const [ extraReducers = {}, actionMatchers = [], defaultCaseReducer = undefined, ] = typeof options.extraReducers === &#39;function&#39; ? executeReducerBuilderCallback(options.extraReducers) : [options.extraReducers] const finalCaseReducers = { ...extraReducers, ...sliceCaseReducersByType } return createReducer( initialState, finalCaseReducers as any, actionMatchers, defaultCaseReducer )}buildReducer中整合了当前slice 的所有reducers，用户自定义的reducer及exterReducers；并返回了createReducer函数执行的结果。我们大概可以预估下这个返回结果，它其实是一个大的reducer处理器，它获取了当前的state及action并进行处理，执行符合触发的action.type的reducer：// 模拟返回reducer(state, action) =&amp;gt; { // filterReducers 复合action的 // 顺序执行filterReducers filterReducers.reduce((preState, filterReducer) =&amp;gt; { //... const nextState = filterReducer(preState, action) return nextState }, state)}在真实的createReducer中，直接看其返回的对象：return function reducer(state, action) { // ... return caseReducers.reduce((previousState, caseReducer): S =&amp;gt; { if (caseReducer) { if (isDraft(previousState)) { //... } else if (!isDraftable(previousState)) { //... } else { return createNextState(previousState, (draft: Draft&amp;lt;S&amp;gt;) =&amp;gt; { return caseReducer(draft, action) }) } } return previousState }, state)}其处理的方式和预想的差不多，其中isDraft和isDraftable是对immer结构的判断；直接看下是原生js对象的情况，其else的处理，返回了一个createNextState函数执行的结果，这个函数同样是immer提供的。createSlice中如何使用了immer？接着上面说，createNextState函数一定返回的是纯js结构，这样就解答我上面提出的愚蠢疑问…return createNextState(previousState, (draft: Draft&amp;lt;S&amp;gt;) =&amp;gt; { return caseReducer(draft, action)})函数的第二参数，即一个回调函数，其入参是draft（即immer提供的proxy对象），其作为reducer的如参，代替了之前的state，因此我们可以在createSlice的reducer中直接修改state，因为这时的state已经是immer对象创建的proxy代理对象了，其内置了set\\get等方法，可以让我们直接对对象、数组、Map、Set进行直接操作。这个proxy的结构：const state: ProxyState = { type_: isArray ? ProxyType.ProxyArray : (ProxyType.ProxyObject as any), // Track which produce call this is associated with. scope_: parent ? parent.scope_ : getCurrentScope()!, // True for both shallow and deep changes. modified_: false, // Used during finalization. finalized_: false, // Track which properties have been assigned (true) or deleted (false). assigned_: {}, // The parent draft state. parent_: parent, // The base state. base_: base, // The base proxy. draft_: null as any, // set below // The base copy with any updated values. copy_: null, // Called by the `produce` function. revoke_: null as any, isManual_: false}createNextState函数即是immer提供的produce对象方法（核心流程）：if (isDraftable(base)) { const scope = enterScope(this) // 通过原始的base，即state，构造了一个proxy对象； const proxy = createProxy(this, base, undefined) let hasError = true try { // recipe在此处即使我们的reducer result = recipe(proxy) hasError = false } finally { // finally instead of catch + rethrow better preserves original stack if (hasError) revokeScope(scope) else leaveScope(scope) } // ... usePatchesInScope(scope, patchListener) // 返回处理的结果 return processResult(result, scope)}在执行reducer的过程中，对state的修改，都会通过proxy对象的traps进行记录和更新，比如set方法，如果对属性进行了更新，会同步到proxy.copy_解构中，这是修改的新的satate的内容，是一个纯js对象。const objectTraps = { set (state, prop, value){ //... // 改变会同步到state.copy_上 state.copy_![prop] = value state.assigned_[prop] = true return true }}因此可以想到processResult返回的就是state.copy_（有新的修改）或者sate.base_（无修改）。最后的巴啦啦到此，上面关于本人提出的疑惑终于解答了：mmer解构只在createSlice/createReducer的reducer中使用了，而其执行后返回的nextState仍然是一个纯js对象。阅读代码的过程中，是一个能更快速了解作者设计意图和实现方式的过程（其实文档中有很多处写到了，但是实在没有好好的阅读），也是自己学习他人设计和实现的便捷路径。我很喜欢作者面对网友质疑的态度，一个开源包的设计是要满足大部分人的场景需求的，但是也不能一味的迎合所有使用者的要求，比如“在createSlice中是否可以关闭immer的使用”这个问题上也有诸多使用者提出了对这个功能的渴求，但作者还是坚持自己的设计理念，并贯彻始终。感恩～～～" }, { "title": "[Leetcode Range Module]-算法解析", "url": "/posts/LeetCode-Range-Module/", "categories": "leetcode, design", "tags": "", "date": "2022-07-05 20:44:02 +0800", "snippet": "题目https://leetcode.com/problems/range-module/分析及实现这道题从分析角度并不难，但本人还是花了几天碎片时间才通过了所有的case，就其原因还是一些边界条件没有梳理清楚。下面根据其需要实现的几个基础（query\\add\\remove）方法进行分析。var RangeModule = function() { this.segs = []};通过segs为维持当前的seg段落，并根据二分查找法对新的seg([a, b])进行搜索，即二分查找寻找其需要插入的segs位置。二分查找实现：RangeModule.prototype._findIndex = function(num, loc) { let l = 0; let r = this.segs.length - 1 while (l &amp;lt;= r) { const mid = ~~((l + r) / 2) const midNum = this.segs[mid][loc] if (midNum === num) return mid else if (midNum &amp;lt; num) { l = mid + 1 } else { r = mid - 1 } } return l}query寻找段落querySeg（[a, b]）。如果寻找成功，意味着，[a, b]与当前segs中的某一个段落seg是有交集的，即：querySeg ⋂ seg === querySeglet leftLoc = this._findIndex(left, 0)let rightLoc = this._findIndex(right, 1)那么针对querySeg，我们通过二分查找，分别找到了leftLoc和rightLoc。（通过二分查找出的loc，包含等于的情况，因此我们需要注意此处的边界条件！）。情况分析： 排除边界（图中的情况A、B） 1.1. 左边界：leftLoc === 0，seg1.left &amp;lt; querySeg.left ，说明超出左边界，返回false； 1.2. 有边界：rightLoc === len, seg4.right &amp;lt; querySeg.right，说明超出右边界，返回false； 修正leftLoc（如果不是等于segs[leftLoc]左边界的情况，需要移动到前一个seg） 2.1. leftLoc !== rightLoc（情况C），未命中同一个seg，返回false； 2.2. leftLoc === rightLoc，如果是情况D，返回false， 否则返回true。 最终实现：RangeModule.prototype.queryRange = function(left, right) { if (this._isEmtpy()) return false const len = this.segs.length let leftLoc = this._findIndex(left, 0) let rightLoc = this._findIndex(right, 1) if (leftLoc === 0 &amp;amp;&amp;amp; this.segs[0][0] &amp;gt; left) return false if (rightLoc === len &amp;amp;&amp;amp; this.segs[len - 1][1] &amp;gt; right) return false if (leftLoc === len || (leftLoc !== 0 &amp;amp;&amp;amp; this.segs[leftLoc][0] !== left)) { leftLoc -= 1 } if (leftLoc !== rightLoc) return false const seg = this.segs[leftLoc] return seg[0] &amp;lt;= left &amp;amp;&amp;amp; seg[1] &amp;gt;= right};addRange插入段落insertSeg[a, b]。let leftLoc = this._findIndex(left, 0)let rightLoc = this._findIndex(right, 1)针对insertSeg，通过二分查找，分别找到了leftLoc和rightLoc。情况分析： 与当前segs有交集，即：this.queryRange(insergSeg) === true，不需要进行插入； 与当前segs无交集，且在边界处： a. 情况A，leftLoc === len，并且当前segs的右边缘seg4.right &amp;lt; querySeg.left，直接插入到尾部this.segs.push(querySeg)； b. 情况B，rightLoc === 0, 并且当前segs的左边缘seg1.left &amp;gt; query.right， 直接插入到头部 this.segs.unshift(querySeg)； 与当前segs无交集，且不在边界处，修正leftLoc及rightLoc（情况C、D），直接进行splice操作，覆盖的seg数量为rightLoc - leftLoc + 1，新的seg其左右值;left: Math.min(left,this.segs[leftLoc][0])right: rightLoc === len ? right : Math.max(right,this.segs[rightLoc][1])实现如下：RangeModule.prototype.addRange = function(left, right) { if (this._isEmtpy()) { this.segs.push([left, right]) return } if (this.queryRange(left, right)) return const len = this.segs.length let leftLoc = this._findIndex(left, 0) if (leftLoc === len &amp;amp;&amp;amp; this.segs[leftLoc - 1][1] &amp;lt; left) { this.segs.push([left, right]) return } if (leftLoc !== 0 &amp;amp;&amp;amp; this.segs[leftLoc - 1][1] &amp;gt;= left) { leftLoc -= 1 } let rightLoc = this._findIndex(right, 1) if (rightLoc === 0 &amp;amp;&amp;amp; right &amp;lt; this.segs[0][0]) { this.segs.unshift([left, right]) return } if (rightLoc !== 0 &amp;amp;&amp;amp; rightLoc !== len &amp;amp;&amp;amp; this.segs[rightLoc][0] &amp;gt; right) { rightLoc -= 1 } this.segs.splice(leftLoc, rightLoc - leftLoc + 1, [ Math.min(left, this.segs[leftLoc][0]), rightLoc === len ? right : Math.max(right, this.segs[rightLoc][1]) ])}removeRange删除段落removeSeg[a, b]。let leftLoc = this._findIndex(left, 0)let rightLoc = this._findIndex(right, 1)针对removeSeg，通过二分查找，分别找到了leftLoc和rightLoc。情况分析： 边界情况： 1.1. 情况A，leftLoc === len，并且当前segs的右边缘seg4.right &amp;lt; querySeg.left，在右边界外，不需要删除； 1.2. 情况B，rightLoc === 0, 并且当前segs的左边缘seg1.left &amp;gt; query.right，在左边界处外，不需要删除； 修正leftLoc、rightLoc： 2.1. 情况C， leftLoc === rightLoc， 并且seg3.left &amp;gt; left &amp;amp;&amp;amp; seg3.right &amp;gt; right，不需要删除； 2.2. 其他情况，均可正常进行移除，这里对移除需要分几种情况： a. 情况D1：leftSeg.left &amp;lt; left &amp;amp;&amp;amp; rightSeg.right &amp;gt; right，这时，removeSeg在某些片段中间，因此会将这些seg删除到只剩下两个片段，分别是[leftSeg[0], left]、[right, rightSeg[1]];b. 情况D2: leftSeg.left &amp;gt;= left，这时我只需要考虑rightSeg被删除的状况，剩下的seg: [right, rightSeg[1]] ;c. 情况D3: right.right &amp;lt;= right，这时我只需要考虑leftSeg被删除的状况，剩下seg: [leftSeg[0], left] ;d. 情况D4: removeSeg完全覆盖了某些seg，只需要删除这些seg即可。实现如下：RangeModule.prototype.removeRange = function(left, right) { if (this._isEmtpy()) return const len = this.segs.length let leftLoc = this._findIndex(left, 0) if (leftLoc === len &amp;amp;&amp;amp; this.segs[leftLoc - 1][1] &amp;lt; left) return if (leftLoc !== 0 &amp;amp;&amp;amp; this.segs[leftLoc - 1][1] &amp;gt;= left) { leftLoc -= 1 } let rightLoc = this._findIndex(right, 1) if (rightLoc === len &amp;amp;&amp;amp; this.segs[rightLoc - 1][1] &amp;lt; left) return if (rightLoc !== 0 &amp;amp;&amp;amp; rightLoc !== len &amp;amp;&amp;amp; this.segs[rightLoc][0] &amp;gt; right) { rightLoc -= 1 } if (leftLoc === rightLoc) { const seg = this.segs[leftLoc] if (seg[0] &amp;gt; left &amp;amp;&amp;amp; seg[0] &amp;gt; right) return } const leftSeg = this.segs[leftLoc] let rightSeg = this.segs[rightLoc] if (!rightSeg) { rightSeg = this.segs[rightLoc - 1] rightLoc -= 1 } const adds = [] if (leftSeg[0] &amp;lt; left &amp;amp;&amp;amp; rightSeg[1] &amp;gt; right) { adds.push([leftSeg[0], left], [right, rightSeg[1]]) } else if (leftSeg[0] &amp;gt;= left) { adds.push([right, rightSeg[1]]) } else if (rightSeg[1] &amp;lt;= right) { adds.push([leftSeg[0], left]) } const params = [leftLoc, rightLoc - leftLoc + 1] if (adds.length &amp;gt; 0) { params.push(...adds) } this.segs.splice(...params)};总结这道题我觉得比较难处理的是对边界的考虑，包括二分查找中还包括等于的情况。但基于上面的分析，其实主要逻辑就是： 处理边界； 修复二分查找的index； 对leftLoc、rightLoc所定位的seg，针对不同场景进行判断： query判断是否为同一个seg，且是其交叉seg的子集； add判断插入的点几插入区间范围； remove判断删除的点及删除后新的seg。 " }, { "title": "Popup如何追踪子组件渲染时机", "url": "/posts/Popup%E5%A6%82%E4%BD%95%E8%BF%BD%E8%B8%AA%E5%AD%90%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%E6%97%B6%E6%9C%BA/", "categories": "antd, popconfirm, react", "tags": "", "date": "2022-06-23 13:35:52 +0800", "snippet": "场景组件库中，我们回经常使用popup类的各种组件：popconfirm、popover、tooltip等popup类组件的特征是：用户触发（hover\\click…）时展示，且组件自身显隐时会触发自定义的动画。现在我们需要处理这样的一个场景，一个popconfirm内需要展示接口请求返回的数据，并且根据组件内一些特征状态，在popconfirm展开时需要定位到active的元素位置。思路我们用antd的popconfirm进行举例，起内部调用关系如下：在Popup组件的实现中，使用CSSMotion对组件的显隐进行动画展示（组件内置）; enter\\appear\\leave状态均使用了此动画时长。.effect() { animation-duration: 0.3s; animation-fill-mode: both;}这为我们拓展了一个思路，是否可以通过监听动画的进度，来获取其content是否被渲染的状态呢？即其popup内部的子组件真正可以被渲染到浏览器上的时机是启动执行enter-active的时机。因此我们可以监听animationStart来获取当前popup组件的classList，如果其包含我们需要的动画class，说明其内部字组件已经渲染到浏览器上了，我们可以对子组件进行需要的业务计算了。解决流程为了便于我们直接获取popup的dom进行监听，我们需要明确popconfirm挂载的dom节点。这里，可以使用popconfirm提供的getPopupContainer方法自定义这个挂载容器节点。 自定义挂载容器节点，当popconfirm的弹窗真正被挂载时，进行下一步的事件监听。const observer = new MutationObserver((mutationsList) =&amp;gt; { for (const mutation of mutationsList) { if (mutation.type === &#39;childList&#39;) { const newNode = mutation.addedNodes[0]; const targetNode = getTargetDom(newNode); if (!targetNode) return; // 挂在后进行事件监听 unListener = registerAEListenEvent(targetNode); } }}); // 对容器节点只进行childList属性变化的监听，即监听何时挂载portal组件observer.observe(observeDom, { subtree: false, attributes: false, childList: true,}); 监听动画事件，并能根据classList判断当前弹窗的状态，比如：// 弹窗是否处于visible状态const checkAntdTooltipVisibleByClassName = classList =&amp;gt; !classList.some(x =&amp;gt; x.includes(&#39;hidden&#39;) || x.includes(&#39;leave&#39;));// 弹窗是否处于动画进入状态const checkAnimateEnterActive = classList =&amp;gt; !classList.some(x =&amp;gt; x.includes(&#39;enter-active&#39;));const registerAEListenEvent = ($dom) =&amp;gt; { if (!$dom) return; const animationStartCb = () =&amp;gt; { const classNameList = [...$dom.classList]; const isVisible = checkAntdTooltipVisibleByClassName(classNameList); const isEnterAcitve = checkAnimateEnterActive(classNameList); if (isEnterAcitve) { // onAnimateStart为用户定义的会调函数 onAnimateStart(isVisible); } }; $dom.addEventListener(&#39;animationstart&#39;, animationStartCb); return () =&amp;gt; { $dom.removeEventListener(&#39;animationstart&#39;, animationStartCb); };};针对react项目，我们完全可以进行自定义hook的封装。 此时通过对动画的监听，我们已经可以明确子组件已经被渲染的时机了；通过业务需要的需要，进行场景计算，比如滚动到active元素的。如果js中需要css中设定的常量，可以使用export的方式，js也可以读取css常量了。:export {...}const [optionHeight, optionGap, scrollGap] = Object.values(pick(CSSVars, [&#39;optionHeight&#39;, &#39;optionGap&#39;, &#39;scrollGap&#39;], [])).map(x =&amp;gt; parseInt(x, 10));const getIntoViewScrollTop = () =&amp;gt; { const $activeOption = scrollRef.current.el.querySelector(`#${activeAudioOptionId}`); const activeDataId = parseInt($activeOption.dataset?.id, 10); if (!$activeOption || activeDataId &amp;lt;= 9) return 0; ...// 需要加计算滚动的scroll距离 return scroll;};// scroll to target locationscrollToTop({ endScrollTop: getIntoViewScrollTop(), animation: false,});总结以上，我们分析并描述了：如何通过监听pop类型组件的animationStart方法，以获取起子组件真正渲染到浏览器的时机。" }, { "title": "【前端自动化基础-npm】npm-scripts 的使用 (1)", "url": "/posts/%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E5%9F%BA%E7%A1%80-npm-npm-scripts-%E7%9A%84%E4%BD%BF%E7%94%A8-(1)/", "categories": "npm, npm-scripts, npm-cli", "tags": "", "date": "2021-08-22 23:23:15 +0800", "snippet": "场景 同一个项目，团队人有使用npm安装有人使用yarn（基于两者的安装策略，可能会造成install的安装的版本有差异），安装的版本有差异，会导致使用方式有些许差异，无法保障一致性； 项目pull后，可能会导致本地的node_modules和package.json有差异，直接运行会报错，但仍无法知道增量的安装package是哪些； 由于项目的多人开发场景，每个人在解决业务问题时会根据自己喜好安装npm包，但可能存在已安装的包已经包含预安装包的功能，但是安装的人并不知晓； … 引出问题以上的这几个场景，其产生的问题是很常见的，产生的问题的原因显而易见，在于“人的变动性”，即无流程约束：因此自动化的工具意义在于，排除人的动态因素，流程化的处理任务，约束行为，避免问题。上面的场景只是项目中问题的冰山一角，今日先从以上的问题下手，慢慢构建一个xx-scripts包，用以流程化处理项目流程。基于npm scripts，来开发我们需要的工具。流程设计npm运行指令时，会经历一些固定的生命周期，先看下经常使用的npm install/npm publish指令执行时会触发哪些。那么，基于指令必经的生命周期，可以指定在某个生命周期执行一些任务，如下：代码实现 package.json中指定bin配置，用户安装后，可执行执行custom-scripts: &quot;bin&quot;: { &quot;custom-scripts&quot;: &quot;./cli.js&quot;}, cli.js中根据custom-scripts提供的command及options来分发任务： #!/usr/bin/env node const exitsNodeModule = require(&#39;./helpers/exitsNodeModule&#39;)if (!exitsNodeModule()) { process.exit(0)} const program = require(&#39;commander&#39;)const chalk = require(&#39;chalk&#39;) // base infoprogram .version(`${require(&#39;./package&#39;).version}`) .usage(&#39;&amp;lt;command&amp;gt; [options]&#39;) // pre-check commandprogram .command(&#39;pre-check&#39;) .description(&#39;help check whether exits packages are not installed&#39;) .option(&#39;-s, --skip&#39;, &#39;if not exits, return true&#39;) .option(&#39;-n, --next &amp;lt;exec&amp;gt;&#39;, &#39;if pre-check is ok, support next exec command&#39;) .action((options) =&amp;gt; { console.log(&#39;options::&#39;, options) require(&#39;./npm/pre-check&#39;)(options) }) // --help tooltipprogram.on(&#39;--help&#39;, () =&amp;gt; { console.log() console.log(` Run ${chalk.cyan(`hq-scripts &amp;lt;command&amp;gt; --help`)} for detailed usage of given command.`) console.log()}) program.parse(process.argv) pre-check中处理逻辑： // ...module.exports = async ({ skip = false, next: nextExecCommand}) =&amp;gt; { // 加载异步模块（esm） await loadGlobalTools() // 检测未安装情况 const checkResult = await checkStatus() // ...异常处理 const [[ unInstallDepPacks, unInstallDevDepPacks ], packageJson] = checkResult if (unInstallDepPacks.length &amp;gt; 0 || unInstallDevDepPacks &amp;gt; 0) { const unInstallPacks = { dep: unInstallDepPacks || [], devDep: unInstallDevDepPacks || [] } const needInstall = await invokeInstallQuestion(unInstallPacks) if (needInstall) { await installPackages(unInstallDepPacks.concat(unInstallDevDepPacks), packageJson) } } if (nextExecCommand) { shellHelper.exec(nextExecCommand) } else if (skip) { return true } else { process.exit(0) }} package.json中指定custom-scripts的执行 scripts: { &quot;start&quot;: &quot;custom-scripts pre-check --next=&#39;npm run dev&#39;&quot;, &quot;dev&quot;: &quot;xxx&quot; ...} 运行指令，结果如下： 总结以上，根据提出的场景问题，我们了解了通过npm scripts生命周期可以帮助我们构建工具解决问题；并通过一个npm run xxx的demo展示了，如何来解决相应的问题。之后继续就场景，进行工具的强化。代码库：custom-scripts" }, { "title": "【源码解读】之 Redux源码解析", "url": "/posts/redux%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/", "categories": "source-code-learning, react, react-redux", "tags": "", "date": "2021-08-15 14:51:00 +0800", "snippet": "前提如果你还是不熟Redux的使用姿势，建议先看下官方文档。多言几句在使用一样工具之前，总是会想到”它“出现的缘由是什么？解决的问题又是什么？工具的优劣势分别是什么，是都能帮助现有项目解决问题？是都会带来衍生问题？…俗话说：”方法总比困难多“，那就简单速览下Redux吧。说起Redux，不得不提起Facebook团队的另一个框架Flux。同MVC模型不同的是，Flux提出的数据流处理模型中是没有Controller的，可以把它看作是controlled-view。Flux的工作模型如下：那既然有了Flux了，为什么还需要Redux？因为Flux其相对的“复杂性”： 调试定位困难 Flux支持多store，store之间可能存在关联关系，触发依赖action； Flux中的store中注册的dispatch需要支持异步处理（提供了waitFor API），可能存在不可预测的异步结果； 基于以上的原因，有了简化版的Redux（我掐指猜测了一下，这个名字是Reduced Flux的意思吧…）： Redux只有一个全局store; Redux通过reducer处理所有的变更，并且都是纯函数，避免了边际效应；因此可以说Redux提供的dispatch(action)都是可预测的行为，保障了我们应用的行为边界预测性，便于测试和debug。但任何工具的引入都会存在利弊，这就涉及到在什么场景下我们需要Redux。当然，官方文档都写的很明白了，查看。源码redux的源码很少，因为其功能单一且独立（纯js，独立于框架）。可以想一下如果我们要实现一个这样库，需要做哪些工作呢？ 创建一个store实例 -&amp;gt; createStore()：这个store提供了一些功能，比如getState()/dispatch/subscribe。 支持middlewares（中间件）扩展能力：中间件让redux有了更为强大的能力，比如redux-thunk使得dispatch支持了异步。combineReducer当我们在写一个reducer的时候，它是一个纯函数，逻辑是这样的：reducer(oldState, action) =&amp;gt; newState当我们有多个reducer的时候，就需要将它聚合起来，通过combineReducer处理，其实返回了一个函数，这个函数的形态（输入、输出）同一个单独的reducer很像，其在内部调用了所有的reducer用以计算新的newState：export default function combineReducers(reducers) { const finalReducers = {} //...统计了有效的reducer const finalReducerKeys = Object.keys(finalReducers) //... return function combination(state, action) { // ... let hasChanged = false const nextState = {} for (let i = 0; i &amp;lt; finalReducerKeys.length; i++) { const key = finalReducerKeys[i] const reducer = finalReducers[key] const previousStateForKey = state[key] const nextStateForKey = reducer(previousStateForKey, action) if (typeof nextStateForKey === &#39;undefined&#39;) { // ... 错误提醒 } // 更具当前的reducer计算key对应的state部分 nextState[key] = nextStateForKey // 只要又一次的reducer计算导致state的变化，就认为是state更新了 hasChanged = hasChanged || nextStateForKey !== previousStateForKey } hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length return hasChanged ? nextState : state }}基础的dispatchredux本身提供的dispatch函数起形态如下：dispatch(action) =&amp;gt; action其中action只能为object对象: { type: xxx, … }，可见其功能也很单一，通过用户触发的action，以计算新的state：function dispatch(action) { //...异常处理 try { isDispatching = true // 根据action计算“新”的state currentState = currentReducer(currentState, action) } finally { isDispatching = false } // 如果有subscribe的订阅者，则执行它们的回调 // nextListeners是在subscribe中动态收集的数组 // currentLiseners是在执行dispatch事被调用的数组，在此时进行赋值 const listeners = (currentListeners = nextListeners) for (let i = 0; i &amp;lt; listeners.length; i++) { const listener = listeners[i] listener() } return action}进阶的dipsptchredux提供的dispatch只支持object对象的方式同步修改state的值，那如果需要异步处理的流程，即dispatch一个函数是否是可行的呢？那这时候就需要我们通过某个方式去改写dipsatch，用以扩展支持function(异步)的情况。还记得前面我们说到，redux本身是纯函数的集合，功能单一，需要扩展功能的话，就需要使用middlewares，即中间件：通过获取用户action来做自定义的行为，比如我们说的redux-thunk、redux-logger等。官方代码对createStore中第三个参数enhancer的解释： * @param enhancer The store enhancer. You may optionally specify it * to enhance the store with third-party capabilities such as middleware, * time travel, persistence, etc. The only store enhancer that ships with Redux * is `applyMiddleware()`.那多个middleware串行工作，就需要一种方式，将任务链关联到一起。middleware的格式化模版如下：({ dispatch, getState }) =&amp;gt; next =&amp;gt; action =&amp;gt; { ... return next(action) }而将任务关联串行的主要工具函数就是compose:compose(...funcs: Function[]) { // ...校验 return funcs.reduce((a, b) =&amp;gt; (...args) =&amp;gt; a(b(...args)))}通过compose函数组合我们可以获知：上一个插件的next的执行函数其实是下一个插件的 (action) =&amp;gt; {}，通过这种方式将任务串联化。applyMiddleware的作用就是通过compose函数构造一条新的dispatch链：applyMiddleware(...middlewares) { return (createStore) =&amp;gt; (reducer, preloadedState) =&amp;gt; { // 在appliMiddleware中构造store才能获取到原始的dispatch const store = createStore(reducer, preloadedState) let dispatch = () =&amp;gt; { //...error deal } const middlewareAPI = { getState: store.getState, dispatch: (action, ...args) =&amp;gt; dispatch(action, ...args) } // ({ getStage, dispatch })注入 const chain = middlewares.map(middleware =&amp;gt; middleware(middlewareAPI)) // 串联到一起 dispatch = compose(...chain)(store.dispatch) return { ...store, dispatch } }}（理解这一块的更好的方式，是自己写几个middleware，体验一下就能更快的理解了）。总结 redux出现的意义及其使用场景； redux是函数式编程的体现，其是纯函数； redux的几个关键：需要管理什么？数据state(通过reducer计算合并) -&amp;gt;需要更新什么？通过dispatch(action)更新数据从而更新视图 -&amp;gt; 如何扩展dispatch为异步？通过redux-thunk等中间件起到加强的作用 -&amp;gt; 如果扩展redux功能？通过middleware插件实现对logger等。" }, { "title": "端开发中的语义化的一些小结", "url": "/posts/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E8%AF%AD%E4%B9%89%E5%8C%96%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E7%BB%93/", "categories": "js", "tags": "", "date": "2021-08-15 12:15:20 +0800", "snippet": "语义化作用说到前端的语义化，我瞬间想起的就是3年前去面试，面试官问题：如何理解html的语义化。对于document文档来说，dom标签的语义化让其名称言简意赅，了然于胸： 对于维护的人友好，方便理解其表层内涵； 对于机器来说是便于理解的，方便解析优化； 常见场景 平时常见的语义化场景： html使用哪些标签：使用语义化的标签代替勤劳楷模“div”； css如何命名（BEM规范等）：根绝场景定义； js变量、函数名称、文件名称，这些都是我们对外提供的，为了让人（或者机器）更好的理解其要维护的内容； 在函数内部，如何语义化？ 拆解函数，细粒度（单一职责-&amp;gt;功能化）、纯粹（纯函数-&amp;gt;少副作用）； 逃不掉的注解（注解的可用性取决于写注解的人的表达能力）； 对于聚合的功能函数，可以使用compose或者lodash里的flow（可以看作是一种pipe的方式）： 我们假设一个业务场景，关闭一个modal弹窗后，我们需要： 重置store； 释放router history block资源； 跳转到目标页面； // beforedispatch({ type: &#39;reset&#39;,})...unblock();history.push(pathname, state)​ 如果通过flow的方式语义化的包裹呢？// afterflow([ function resetStore() { dispatch({ type: &#39;reset&#39;, }) }, function releaseRouteBlockEventResource() { unblock() }, function jumpToTargetRoute { history.push(pathname, state) },])虽然，多了很多行代码，但这样组合的方式，我个人觉得是更加语义化的（此处，你不需要写注释了），并且起到了功能隔离的作用。 使用React框架，语义化 组件名称明确且场景化，通过displayName提供，也便于使用dev tools调试时，便于定位组件进行调试； 类组件中生命周期已经明确化每个组件每个阶段需要做的事情，内部函数的语义化参考上面的； 函数组件没有生命周期，（hook之前）一般是纯UI的组件，明确其props的含义即可； 函数组件，通过hook方式提供状态类组件（受控 or 非受控），我们通过其提供的hook函数或者我们自定义的hook进行功能的抽象和封装，而自定义hook的方式（即对hook的命名）已经对其功能语义化了，但我们也可以通过像处理函数流程语义化的方式来处理hook的流程化； ​ 同样，我们来for example， 在进入某个页面时，我们需要完成一下职责功能： ​ a. beforeunload事件注册； ​ b. routeBlockEvent注册； ​ c. 请求资源； ​ d. store的一些初始化(数据同步)； ​ e. 业务功能的其他监听事件； // before beforefunction XXXPage(props) { // a event useEffect(() =&amp;gt; { window.addEventListener(&#39;beforeunload&#39;, xxx) return () =&amp;gt; { xxx } }, [xxx]) // b event useEffect(() =&amp;gt; { const unblock = history.block(() =&amp;gt; {xxx}) return () =&amp;gt; { unblock() } }, [xxx]) // c event useEffect(async () =&amp;gt; { await Promise.all([dispatch(xxxAction), dispatch(xxxAction)]) ... }, [xxx]) // d event useEffect(() =&amp;gt; { if (matchCondition) { syncData(xxx) } .... }, [xxx]) // e event useDeepEffect(() =&amp;gt; { // some side effect }, [xxx]) return &amp;lt;UI {...props} /&amp;gt;} 我们可以看到，我们抽象的逻辑其实可能和view层毫无关系，都是一些全局或者预加载资源；我们可以通过自定义hook的方式将功能抽离，语义化hook的功能。 // beforefunction XXXPage(props) { // a event useEffect(() =&amp;gt; { window.addEventListener(&#39;beforeunload&#39;, xxx) return () =&amp;gt; { xxx } }, [xxx]) // b event useRouteBlock(props) // c event useGetXXXResource(props) // d event useSyncXXXData(props), // e event useXXXChange(props) return &amp;lt;UI {...props} /&amp;gt;} 那如何像flow的方式去从代码层面切割这些和View层主逻辑没有太大关系的hook功能呢？这里想到了高阶组件，高阶组件的出现是为了代替mixin，以一个低侵入性的方式抽象更为高阶的逻辑方式。那如何将hook作为props封装高阶组件呢？（这里参考了hooks-into-props）其仅支持单一hook）。 // hook执行暴露的返回const getMergedHooksProps = (useHooks, props) =&amp;gt; useHooks.reduce((mergedHookProps, useHook) =&amp;gt; { const hookActions = useHook(props) ?? {} for (const key in hookActions) { mergedHookProps[key] = hookActions } return mergedHookProps }, {}) // hooks into propsconst hooksIntoProps = (...useHooks) =&amp;gt; (Component) =&amp;gt; { const EnhancedComponentWithHooks = forwardRef((props, ref) =&amp;gt; { return React.createElement(Component, { ref, ...props, ...getMergedHooksProps(useHooks, props), }) }) EnhancedComponentWithHooks.displayName = `EnhancedComponentWithHooks(${ Component.displayName || Component.name || &#39;Component&#39; })` return hoistNonReactStatics(EnhancedComponentWithHooks, Component) } export default hooksIntoProps 此时，我们可以通过高阶函数的方式注入hook功能了： // nowhooksIntoProps( () =&amp;gt; { // reload前询问 useEventListener({ type: &#39;beforeunload&#39;, cb: (ev) =&amp;gt; { ev.returnValue = tipLabel return false }, }) }, // route切换前询问 useRouteBlock, // 请求资源 useGetXXXResource, // 同步数据 useSyncXXXData, // ... useXXXChange,)(XXXPage) 这种方式，非常直观明了的展示，我们对这个页面进行了哪些操作，而不是面条式的堆叠了代码，并且给予了更好的语义化。 （其他场景之后待补充…）" }, { "title": "如何用react hooks封装功能之切换 Dark/Light Mode？", "url": "/posts/%E5%A6%82%E4%BD%95%E7%94%A8react-hooks%E5%B0%81%E8%A3%85%E5%8A%9F%E8%83%BD%E4%B9%8B%E5%88%87%E6%8D%A2%E6%B7%B1%E6%B5%85%E6%A8%A1%E5%BC%8F/", "categories": "react, react-hooks, dark-mode", "tags": "", "date": "2021-08-14 14:45:00 +0800", "snippet": "Dark Mode?Coder们喜欢Dark mode，为什么？因为深色模式让环境变暗，在阅读或者使用编辑器的场景非常利于人的注意力的集中，可以专注在亮色信息上；但其实也只有在上述的两个场景下使用深色模式才是被需求的场景，而在其他场景下（比如浏览淘宝、京东等），深色模式其实是对眼睛不友好的：“原因在于，在白底黑字的情况下，人类的双眼能接收到更多的光线，虹膜会有更多部分选择闭合，晶状体的形变也相对较少；但在黑底白字的情况下，为了提高对光线的吸收，虹膜便会张得更开，晶状体的形变也会变大，反而更容易造成眼部疲劳。”但深色/浅色模式已经成为系统内置的一部分，在平时的UI设计中也会涉及到主题切换时的样式变化、web icon变化等，那如何去判断去获取当前的主题色系呢？主题色系变化后如何监听到呢？MediaQueryList API我们先看下其兼容性，emmmm….不容乐观呢，此实验属性为实验功能，因此其兼容性尚得不到保证。我们洗三看下mediaQueryList是啥？ 一个MediaQueryList对象在一个document上维持着一系列的媒体查询 (en-US)，并负责处理当媒体查询在其document上发生变化时向监听器进行通知的发送。那我们通过什么来创建这样一个媒体查询呢？答案：matchMedia。总结一下，流程如下： 通过matcheMedia(‘xxx’)创建一个新的mediaQueryList对象； mediaQueryList.matches ：当前document是否匹配媒体查询； 如果匹配媒体查询，可以通过addEventListener(‘change’, function listenChange() {})来添加对媒体查询变更的监听，通过removeEventListener(‘change’, function listenChange() {}) 卸载监听。使用hook封装这个hook的功能如下： 当前活跃的activeTheme；（用户通过这个theme也知道其是否为有效theme） 提供onChange，作为theme变更时的用户回调监听函数；import { useState, useEffect, useCallback } from &#39;react&#39;function useTheme() { const [theme, setTheme] = useState(() =&amp;gt; { const supportCurrentMedia = window.matchMedia( &#39;(prefers-color-scheme)&#39;, ).media return supportCurrentMedia !== &#39;not all&#39; ? window.matchMedia(&#39;(prefers-color-scheme: dark)&#39;).matches ? &#39;dark&#39; : &#39;light&#39; : &#39;&#39; }) const onChange = useCallback( (fn) =&amp;gt; { return fn(theme) }, [theme], ) useEffect(() =&amp;gt; { if (theme === &#39;not all&#39;) { throw Error(&#39;Browser doesn\\&#39;t support dark mode&#39;) } const listenThemeChange = (theme) =&amp;gt; (e) =&amp;gt; { if (e.matches) { setTheme(theme) } } const darkMediaQuery = window.matchMedia(&#39;(prefers-color-scheme:dark)&#39;) const lightMediaQuery = window.matchMedia(&#39;(prefers-color-scheme:light)&#39;) const [darkThemeChangeListener, lightThemeChangeListener] = [ listenThemeChange(&#39;dark&#39;), listenThemeChange(&#39;light&#39;), ] // 深色 darkMediaQuery.addEventListener(&#39;change&#39;, darkThemeChangeListener) // 浅色 lightMediaQuery.addEventListener(&#39;change&#39;, lightThemeChangeListener) return () =&amp;gt; { darkMediaQuery.removeEventListener(&#39;change&#39;, darkThemeChangeListener) lightMediaQuery.removeEventListener(&#39;change&#39;, lightThemeChangeListener) } // eslint-disable-next-line react-hooks/exhaustive-deps }, []) return { theme, onChange, }}export default useTheme使用：const [theme, listenThemeChange] = useTheme()console.log(&#39;current theme&#39;, theme)listenThemeChange((theme) =&amp;gt; { // do sth if theme change~})自定义hooks: Just package top logic code, don’t repeat yourself（DRY）。" }, { "title": "Axios是如何取消一个request？", "url": "/posts/Axios%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%96%E6%B6%88%E4%B8%80%E4%B8%AArequest/", "categories": "js, axios", "tags": "", "date": "2021-08-13 22:33:21 +0800", "snippet": "前端同学对axios都非常熟悉，它是活跃在大家项目里负责网络请求的热门库。在业务项目中，我们通常会配置化axios的使用实例（如指定baseUrl、timeout等），方便好用的request和response拦截器也提供了通用逻辑处理的方式。今天想谈论的一个问题是，axios是如何取消一个已发送的request的呢？问题场景那为什么需要处理这个问题呢？我们平时遇到的哪些业务场景需要这个方法呢？ 用户inpu输入频繁请求； 用户选择组合式表单触发实时频繁的请求； 用户频繁切换tab获取activeTab下的数据； … 这些问题统一为：用户行为频繁触发 -&amp;gt; 引发数据store变更 -&amp;gt; 触发store变更的监听 -&amp;gt; 触发网络请求问题分析当我们分析一个问题的解决思路时，我们必须清楚我们面临的问题，其触发的流程是怎么样的（步骤）、问题可以在哪些点被规避（关键点）、思考规避的方法并实践（方案比较）。那在这个问题中，我找到的两个点是： 减少用户高频率触发请求，使用debounce（比如在100ms内只能触发3次）； 对于相当store的触发的情况下，新request发送前取消之前的request；对于第二点，对于不需要考虑网络资源的场景来说，可以不考虑cancel的方式，可以思考如果获取最新一次的网络请求结果。Axios的cancel是如何实现的？那如何取消一个网络请求呢？我们知道axios其内部实现的adapter（brower端）使用的是xhr（node使用的是http模块）。而原生xhr是有提供取消网络请求事件的方法，其名曰：abort。看下MDN上的描述： 如果该请求已被发出，XMLHttpRequest.abort() 方法将终止该请求。当一个请求被终止，它的 readyState 将被置为 XMLHttpRequest.UNSENT，并且请求的 status 置为 0。再看下其兼容性：Full support，因此我们可以暂时不考虑polyfill的方法，通过调用axios提供的cancel方法即可解决问题。我们可以思考一下，如果让我们来实现一个这样的场景，我们会怎么做？// 创建一个xhrconst xhr = new XMLHttpRequest()xhr.open(&#39;post&#39;, data)// ...参数配置xhr.onreadystatechange = () =&amp;gt; { if(xhr.readyState === XMLHttpRequest.DONE &amp;amp;&amp;amp; xhr.status === 200) { console.log(xhr.responseText) }}xhr.send()// 使用者打算取消，直接调用abort就行了xhr.abort()如果是使用原生xhr就是这么的简单，那使用Axios呢？它的内部是如何处理的呢？也很简单。看一个官网的demo：const CancelToken = axios.CancelToken;let cancel;axios.get(&#39;/user/12345&#39;, { cancelToken: new CancelToken(function executor(c) { // An executor function receives a cancel function as a parameter cancel = c; })});// cancel the requestcancel();(两种方式，或者通过cancelToken的source方法获取token + cancel，本质都是相同的)。这个CancelToken通过实例化的方法提供了一个token，axios通过配置信息获取这个token后，当前发起的request就和token创建了关联；而当用户调用cancel的方法时，这个request就会被取消。那token到底是什么呢？我们先看下CancelToken的源码：function CancelToken(executor) { if (typeof executor !== &#39;function&#39;) { throw new TypeError(&#39;executor must be a function.&#39;); } var resolvePromise; this.promise = new Promise(function promiseExecutor(resolve) { resolvePromise = resolve; }); var token = this; executor(function cancel(message) { if (token.reason) { // Cancellation has already been requested return; } token.reason = new Cancel(message); resolvePromise(token.reason); });}实例化一个CancelToken，相当于得到了一个promise（即配置中的cancelToken），而这个promise的resolve其实是交给了cancel函数，即当用户调用cancel函数时，这个promise才被resolved。那这个逻辑就很容易理解了，用户调用cancel，promise被resolved，可以通过promise.then(() =&amp;gt;{ xhr.abort() })来实现请求的取消。业务中如何处理我们需要一个service帮助我们收集某个url发起的request请求，如果该请求时需要进行debouceCancel处理的，那我们就 在配置中为其自动添加cancelToken； 并且有一个栈去存储当前url对应的cancelToken（promise）； 为了满足多个url的处理，我们需要一个map结构存储信息&amp;lt;url: string, token: Pomise[]&amp;gt;; 当有一个新的请求发送时，我们将其拦截，查看map结构获取之前的请求token序列，调用所有token的cancel方法，取消xhr。首先，我们要拦截request，通过axios提供的interceptors.request.use：axios.interceptors.request.use((config) =&amp;gt; { const { cancel, url } = config // 自定义配置，是否需要debounceCancel if (!cancel) return config requestCancelService.register(url) return requestCancelService.proxyRequst(config)})requestCancelService的实现：import Axios from &#39;axios&#39;import { isEmpty } from &#39;lodash-es&#39;class RequestCancelService { constructor() { this.map = new Map() } // 注册url register(url) { if (this.map.has(url)) return this.map.set(url, []) } clearCancelResource(url) { this.map.set(url, []) } // 添加 addCancelResource(url, source) { this.map.get(url)?.push(source) } proxyRequst(axiosConfig) { const { url } = axiosConfig const cancelResources = this.map.get(url) if (!isEmpty(cancelResources)) { const copyCancelResources = [...cancelResources] this.clearCancelResource() // 取消之前的request copyCancelResources.forEach((cancelInvoker) =&amp;gt; { cancelInvoker?.cancel() }) } const CancelToken = Axios.CancelToken const source = CancelToken.source() // create new cancelToken axiosConfig.cancelToken = source.token this.addCancelResource(url, source) return axiosConfig }}const requestCancelServiceInstance = new RequestCancelService()export default requestCancelServiceInstance总结综上所述，描述了： 在什么场景下我们需要取消一个request； axios如何使用xhr.abort来取消一个request的； 我们在业务中如果通用化axios配置帮助解决这个问题的。" }, { "title": "【源码解读】之 vuex源码解析", "url": "/posts/vuex%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/", "categories": "source-code-learning, vue, vuex", "tags": "", "date": "2021-08-12 14:51:00 +0800", "snippet": "背景https://vuex.vuejs.org/zh/Vuex灵感来自于Flux，它们都是“单根”（而为什么是单根的，我想可能是为了明确一个mutation或者action来自于一个明确的module吧）为了维护庞大的store，可以通过modules拆分进行状态维护。看下Module的定义：// Base data struct for store&#39;s module, package with some attribute and methodexport default class Module { constructor (rawModule, runtime) { this.runtime = runtime // Store some children item this._children = Object.create(null) // Store the origin module object which passed by programmer this._rawModule = rawModule const rawState = rawModule.state // Store the origin module&#39;s state this.state = (typeof rawState === &#39;function&#39; ? rawState() : rawState) || {} } get namespaced () { return !!this._rawModule.namespaced } ...}从其属性_children我们看出，module其实可以被“无限”嵌套。如果module定义了namespaced： true（为了使模块更为功能独立），那么在调用时需要指定module的path；如果namespaced: false，那么如果多个module定了同名mutation， commit时会同时触发（但子module有其独立的state）；比如我们定义一个store如下：// root state{ state: () =&amp;gt; { return { name: &#39;xxxx&#39;} }, ..., modules: { moduleA: { namespaced: true, moduleAA: {...} }, moduleB: { namespaced: true, } }}// 构造出的module结构为// {// &#39;moduleA&#39;: {// &#39;moduleAA&#39;: xxx// },// &#39;moduleB&#39;: xxx// }当然，代码实现上，为了使得寻找模块更为快速，在store上用__modulesNamespaceMap来记录{[path]: module}之间的映射关系。以上面的demo为例子：{‘moduleA’: xxx, ‘moduleB’: xxxx, ‘moduleA/moduleAA’: xxx}。源码分析Vuex如何构造state的呢？ 对rootState的监听，构造reactive的方式：// bind store public gettersstore.getters = {}// reset local getters cachestore._makeLocalGettersCache = Object.create(null)const wrappedGetters = store._wrappedGettersconst computed = {}forEachValue(wrappedGetters, (fn, key) =&amp;gt; { // use computed to leverage its lazy-caching mechanism // direct inline function use will lead to closure preserving oldVm. // using partial to return function with only arguments preserved in closure environment. computed[key] = partial(fn, store) Object.defineProperty(store.getters, key, { get: () =&amp;gt; store._vm[key], enumerable: true // for local getters })})store._vm = new Vue({ data: { $$state: state }, computed})在resetStoreVM实现中，可以看到store._vm是一个vue实例，而根state就维护在data下；获取根rootState就可以通过this._vm._date.$$state会去到。而对于getter的处理都归类为computed的处理了。 对modules构造reactive的方式： // set state if (!isRoot &amp;amp;&amp;amp; !hot) { const parentState = getNestedState(rootState, path.slice(0, -1)) const moduleName = path[path.length - 1] store._withCommit(() =&amp;gt; { if (__DEV__) { if (moduleName in parentState) { console.warn( `[vuex] state field &quot;${moduleName}&quot; was overridden by a module with the same name at &quot;${path.join(&#39;.&#39;)}&quot;` ) } } Vue.set(parentState, moduleName, module.state) }) }在installModule的处理过程中，对于不是根组件的state，都会通过Vue.set方式，在parentState上动态构造module.state；通过Vue.set的方式添加对module.state变更的监听。 对getters的监听在installModule处理中，把每个getter都统一到store._wrappedGetters中：store._wrappedGetters[type] = function wrappedGetter (store) { return rawGetter( local.state, // local state local.getters, // local getters store.state, // root state store.getters // root getters ) }在代码1中，我们看到其在构造vue实例的computed属性时，将所有的_wrappedGetters都挂在了computed下。对mutation的处理同对getter的处理方式类似，所有的mutation都挂载在实例store的_mutations下了：function registerMutation (store, type, handler, local) { const entry = store._mutations[type] || (store._mutations[type] = []) entry.push(function wrappedMutationHandler (payload) { handler.call(store, local.state, payload) })}对action的处理同mutation的处理类似，但是需要考虑action是异步的情况：判断处理的cb是否返回的为Promise：const entry = store._actions[type] || (store._actions[type] = [])entry.push(function wrappedActionHandler (payload) { let res = handler.call(store, { dispatch: local.dispatch, commit: local.commit, getters: local.getters, state: local.state, rootGetters: store.getters, rootState: store.state }, payload) if (!isPromise(res)) { res = Promise.resolve(res) } ...通过以上的处理，store的初始化已被完成，包括： store.state （可以获得根rootState，通过namespace path获取module.state），这其中也包括对getters的获取； store._mutations包含对mutation的处理； store._actions包含对action的处理；store.committhis.commit = function boundCommit (type, payload, options) { return commit.call(store, type, payload, options)}通过上面store._mutations的封装，commit方法会通过type获取对应的mutations，在执行mutation后需要需要通知所有的subscribers。this._subscribers .slice() // shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe .forEach(sub =&amp;gt; sub(mutation, this.state))store.dispatch对于action的操作要考虑其为处理异步的特性，在上面的_actions中，已经将所有的action返回结果包裹为Promise了。const result = entry.length &amp;gt; 1 ? Promise.all(entry.map(handler =&amp;gt; handler(payload))) : entry[0](payload)return new Promise((resolve, reject) =&amp;gt; { result.then(res =&amp;gt; { try { this._actionSubscribers .filter(sub =&amp;gt; sub.after) .forEach(sub =&amp;gt; sub.after(action, this.state)) } catch (e) { if (__DEV__) { console.warn(`[vuex] error in after action subscribers: `) console.error(e) } } resolve(res) }, error =&amp;gt; { try { this._actionSubscribers .filter(sub =&amp;gt; sub.error) .forEach(sub =&amp;gt; sub.error(action, this.state, error)) } catch (e) { if (__DEV__) { console.warn(`[vuex] error in error action subscribers: `) console.error(e) } } reject(error) })})vuex的应用vuex同其他vue插件一样，提供了install方法，用于注入Vue及通过Vue.mixin的方式进行混入。vuex提供的helpers方法：mapState、mapGetters、mapMutations、mapActions等，都只是通过以上收集的modules、store.getters、store.state、local context等进行分解注入。总结总体来看，vuex的结构是非常清晰、简洁的，对于reactive的部分直接使用了Vue的能力，watch的部分也是Vue提供的能力，因此其主要的工作在于构造模块路径关系。同redux（纯函数，真的很纯粹）相比，vuex使用了vue提供的reactive能力，其提供的nested modules（内部也进行了优化，方法快速定位某个type的module，而不是像redux那样，需要run所有的reducers获取最新的state），动态注册module也非常的方便，但这是redux并没有提供的能力。" } ]
