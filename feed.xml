<feed xmlns="http://www.w3.org/2005/Atom"> <id>/</id><title>UnlimitedZone</title><subtitle>你看，天上的✨，在它们的背后，是我们还无法看到的世界，这是不是让人期待呢？</subtitle> <updated>2022-09-22T11:02:12+08:00</updated> <author> <name>WonderQrunMan</name> <uri>/</uri> </author><link rel="self" type="application/atom+xml" href="/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="/"/> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2022 WonderQrunMan </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>js实现PriorityQueue类</title><link href="/posts/js%E5%AE%9E%E7%8E%B0PriorityQueue%E7%B1%BB/" rel="alternate" type="text/html" title="js实现PriorityQueue类" /><published>2022-09-16T15:08:00+08:00</published> <updated>2022-09-16T15:08:00+08:00</updated> <id>/posts/js%E5%AE%9E%E7%8E%B0PriorityQueue%E7%B1%BB/</id> <content src="/posts/js%E5%AE%9E%E7%8E%B0PriorityQueue%E7%B1%BB/" /> <author> <name>WonderQrunMan</name> </author> <category term="data-construct" /> <category term="queue" /> <category term="priority-heap" /> <summary> js原生是没有提供这种复杂数据结构的（默默的羡慕一下java的世界）。 为什么需要这种结构的呢？这种结构的优势又是什么呢？ Queue vs PriorityQueue 我们对这个词都不陌生，女王，哦，不，是：队列。 队列的特点就是“先进先出”，进、出的时间效率都是O(1)；在js世界中，使用朴素的Array结构就可以模拟。那如果进、出都是有条件的，我们会怎么处理呢？ 比如，一堆学生在一个房间里，现在需要一个一个按需叫他们出来谈话，我们现在定一个规则就是O(1)时间内，按照学生的身高由高到低出来；而在谈话的过程中呢，又会有一些新的学生进入教室，那我们就需要通过某种结构进行管理，某种方法进行插入，以达到我们能O(1)效率找到当前学生中最高的目标。 列举的这个场景，比较的维度还是线性的：身高（数值对比）。数据结构中的大顶堆可以解决这个问题。 那如果现在排序的规则发生变化了呢？诸如，... </summary> </entry> <entry><title>如何使用数据结构解决数据依赖的问题</title><link href="/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E4%BE%9D%E8%B5%96%E7%9A%84%E9%97%AE%E9%A2%98/" rel="alternate" type="text/html" title="如何使用数据结构解决数据依赖的问题" /><published>2022-09-16T15:08:00+08:00</published> <updated>2022-09-16T15:08:00+08:00</updated> <id>/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E4%BE%9D%E8%B5%96%E7%9A%84%E9%97%AE%E9%A2%98/</id> <content src="/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E4%BE%9D%E8%B5%96%E7%9A%84%E9%97%AE%E9%A2%98/" /> <author> <name>WonderQrunMan</name> </author> <category term="sideEffect" /> <category term="tree" /> <summary> 背景 比如如下的场景，在一个数据洞察的场景下，筛选器之间的值存在相互的依赖关系（但不会构成环）； 这个图中标注了筛选器之间的依赖关系。那我们如何能更好的抽象一种能力，去解决这种依赖关系呢？ 树结构 通过这个图和实际场景的逻辑关系，我们能发现，箭头是不会构成环的，否则会导致依赖无限循环下去。 根据上图的案例我们可以抽象出其有向图的结构： 比如，我们切换了province，那在图中我们找到了代表这个值的节点，并递归向下获取其所有子孙节点的最新值（同步/异步请求获取数据集合）。基于业务场景并不存在root到某个叶子节点的路径有&amp;gt;=2的可能性，因此我们可以用树结构来抽象这层关系。 因此，到这里我们需要做的几件事情： 构造节点； 构造树关系； 实现某个节点的值变化，递归收集其子孙的最新值； class TreeNode { constructor(... </summary> </entry> <entry><title>如何判断图片的实际类型?</title><link href="/posts/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%9B%BE%E7%89%87%E7%9A%84%E5%AE%9E%E9%99%85%E7%B1%BB%E5%9E%8B/" rel="alternate" type="text/html" title="如何判断图片的实际类型?" /><published>2022-07-15T16:01:19+08:00</published> <updated>2022-07-15T16:02:32+08:00</updated> <id>/posts/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%9B%BE%E7%89%87%E7%9A%84%E5%AE%9E%E9%99%85%E7%B1%BB%E5%9E%8B/</id> <content src="/posts/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%9B%BE%E7%89%87%E7%9A%84%E5%AE%9E%E9%99%85%E7%B1%BB%E5%9E%8B/" /> <author> <name>WonderQrunMan</name> </author> <category term="redux" /> <category term="redux-tooltik" /> <category term="immer" /> <summary> 背景 场景需要能够真实的判断图片的类型，针对上传等任务对不符合的文件类型在前端侧进行拦截。 比如用户将动态的webp图片类型手动改为png，只通过file.type检查文件的类型其实不是其actual type。 因此需要提供一种更为有效的方式来判断图片的真实类型。 解决方法 任何文件的实质都是一堆二进制，而有一个称为“magic number”的序列被标注为识别文件唯一类型的签名。 如果我们知道了不同文件类型的文件头签名，就可以通过分析文件数据对文件进行类别的判断了呢？ 在wiki上提供了一个不同文件类型的签名列表信息，因为需求暂时只涉及一些常见图片类型的处理，我们只需要考虑images/png、images/jpeg、images/gif、images/svg + xml 、images/webp等。（需要完成的图片类型，可参考 完整图片类型） (黄色标注的部分，... </summary> </entry> <entry><title>@redux-tooltik是如何使用immer的？</title><link href="/posts/@redux-tooltik%E6%98%AF%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8immer%E7%9A%84/" rel="alternate" type="text/html" title="@redux-tooltik是如何使用immer的？" /><published>2022-07-08T15:20:54+08:00</published> <updated>2022-07-08T16:34:48+08:00</updated> <id>/posts/@redux-tooltik%E6%98%AF%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8immer%E7%9A%84/</id> <content src="/posts/@redux-tooltik%E6%98%AF%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8immer%E7%9A%84/" /> <author> <name>WonderQrunMan</name> </author> <category term="redux" /> <category term="redux-tooltik" /> <category term="immer" /> <summary> 一些碎碎念 使用redux，是为了做复杂的数据管理；但对于很多使用redux的人来说，配置繁琐而重复的模版文件，简直是一场永无止尽的噩梦。 我们需要reducer； 我们需要action; 我们需要异步action； 我们需要确认，在reducer中修改嵌套过深的state是否有效，否则会导致react-redux中判断shouldComponentUpdate失效，从而无法进行组件re-render； … 写到这里我已经感到痛心疾首了，我们为了解决一个问题，又引入了另一问题；但是还好这个世界总是有“聪明的人”存在，开发出省时省力的工具，帮助开发人员们降低理解及使用成本（羡慕不已）。 使用体验 从我自己使用RTK来说，我个人感觉很好用的就是其文档中描述的： 降低了写reducer及action的成本，通过create... </summary> </entry> <entry><title>[Leetcode Range Module]-算法解析</title><link href="/posts/LeetCode-Range-Module/" rel="alternate" type="text/html" title="[Leetcode Range Module]-算法解析" /><published>2022-07-05T20:44:02+08:00</published> <updated>2022-07-05T21:18:40+08:00</updated> <id>/posts/LeetCode-Range-Module/</id> <content src="/posts/LeetCode-Range-Module/" /> <author> <name>WonderQrunMan</name> </author> <category term="leetcode" /> <category term="design" /> <summary> 题目 https://leetcode.com/problems/range-module/ 分析及实现 这道题从分析角度并不难，但本人还是花了几天碎片时间才通过了所有的case，就其原因还是一些边界条件没有梳理清楚。下面根据其需要实现的几个基础（query\add\remove）方法进行分析。 var RangeModule = function() { this.segs = [] }; 通过segs为维持当前的seg段落，并根据二分查找法对新的seg([a, b])进行搜索，即二分查找寻找其需要插入的segs位置。 二分查找实现： RangeModule.prototype._findIndex = function(num, loc) { let l = 0; let r = this.segs.length - 1 while (l &amp;l... </summary> </entry> </feed>
